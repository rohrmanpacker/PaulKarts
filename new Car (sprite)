package paulkarts;

import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.canvas.GraphicsContext;
import javafx.geometry.Rectangle2D;
import javafx.scene.transform.Rotate;

public class Car
{
	private ImageView imageView;
	private double positionX;
	private double positionY;    
	private double velocity;
	private double angle;
	private double width;
	private double height;
	private double acceleration;


	public Car(double x, double y){
		imageView =new ImageView();
		imageView.setRotate(90);
		positionX=x;
		positionY=y;
		velocity = 0;
		acceleration=0;
		angle = 270;
	}

	public Car()
	{
		this(0,0);    
	}

	public void setImage(Image i)
	{
		imageView.setImage(i);
		width = i.getWidth();
		height = i.getHeight();
		imageView.setRotate(angle);
	}

	public void setImage(String filename)
	{
		Image i = new Image(filename);
		setImage(i);
	}

	public Image getImage(){
		return imageView.getImage();
	}
	
	public ImageView getImageView(){return imageView;}

	public double getX(){
		return positionX;
	}
	public double getY(){
		return positionY;
	}
	public double getAcceleration(){return acceleration;}
	public double getVelocity(){return velocity;}
	public double getAngle(){return angle;}

	public void setPosition(double x, double y)
	{
		positionX = x;
		positionY = y;
	}

	public void rotate(double angleChange){
		angle+=angleChange;
		imageView.setRotate(angle);
	}

	public void setVelocity(double v)
	{
		velocity = v;
	}

	public void addVelocity(double v)
	{
		velocity += v;
	}
	
	public void accelerate(double a){
		acceleration+=a;
	}
	
	
	
	public void update(double time)//this is what gets run to update the position. vel, accel, etc.
	{
		imageView.setRotate(angle);
		velocity += acceleration*time/10;
		
		if(velocity>.1){//sets max speed
			velocity=.1;
		}else if(velocity<-.1){
			velocity =-.1;
		}
		if(acceleration>1){//sets max acceleration
			acceleration=1;
		}else if(acceleration<-1){
			acceleration =-1;
		}
		
		positionX += velocity * time * Math.cos(Math.toRadians(angle));
		positionY += velocity * time * Math.sin(Math.toRadians(angle));
		if(velocity>0){//slowing down
			velocity-=.001;
		}else if(velocity<0){
			velocity+=.001;
		}
		if(velocity<.001&&velocity>0||velocity>-.001&&velocity<0){//gets rid of rounding errors 
			velocity=0;
		}
		
		acceleration=0;
		
		
	}

	public void render(GraphicsContext gc)
	{
		gc.drawImage( imageView.getImage(), positionX, positionY );
	}

	public Rectangle2D getBoundary()
	{
		return new Rectangle2D(positionX,positionY,width,height);
	}

	public boolean intersects(Car s)
	{
		return s.getBoundary().intersects( this.getBoundary() );
	}

	public String toString()
	{
		return " Position: [" + positionX + "," + positionY + "]" 
				+ " Velocity: [" + velocity + "]" + " Angle: [" + angle + "]";
	}
	
	/**
     * Sets the transform for the GraphicsContext to rotate around a pivot point.
     *
     * @param gc the graphics context the transform to applied to.
     * @param angle the angle of rotation.
     * @param px the x pivot co-ordinate for the rotation (in canvas co-ordinates).
     * @param py the y pivot co-ordinate for the rotation (in canvas co-ordinates).
     */
    public void rotate(GraphicsContext gc, double angle, double px, double py) {
        Rotate r = new Rotate(angle, px, py);
        gc.setTransform(r.getMxx(), r.getMyx(), r.getMxy(), r.getMyy(), r.getTx(), r.getTy());
    }
    
    /**
     * Draws an image on a graphics context.
     *
     * The image is drawn at (tlpx, tlpy) rotated by angle pivoted around the point:
     *   (tlpx + image.getWidth() / 2, tlpy + image.getHeight() / 2)
     *
     * @param gc the graphics context the image is to be drawn on.
     * @param angle the angle of rotation.
     * @param tlpx the top left x co-ordinate where the image will be plotted (in canvas co-ordinates).
     * @param tlpy the top left y co-ordinate where the image will be plotted (in canvas co-ordinates).
     */
    public void drawRotatedImage(GraphicsContext gc, Image image, double angle, double tlpx, double tlpy) {
        gc.save(); // saves the current state on stack, including the current transform
        rotate(gc, angle, tlpx + image.getWidth() / 2, tlpy + image.getHeight() / 2);
        gc.drawImage(image, tlpx, tlpy);
        gc.restore(); // back to original state (before rotation)
    }

}
